package services

import (
	"context"
	"fmt"
	"time"

	"github.com/you/rt-quiz/client/redis"
	"github.com/you/rt-quiz/models"
	"github.com/you/rt-quiz/repository"
)

// QuizService handles quiz lifecycle business logic
type QuizService struct {
	quizRepo    repository.QuizRepository
	resultRepo  repository.ResultRepository
	redisClient redis.Client
}

// NewQuizService constructs a QuizService
func NewQuizService(qr repository.QuizRepository, rr repository.ResultRepository, rc redis.Client) *QuizService {
	return &QuizService{
		quizRepo:    qr,
		resultRepo:  rr,
		redisClient: rc,
	}
}

// CreateQuiz creates a new quiz in pending status
func (s *QuizService) CreateQuiz(ctx context.Context, quiz *models.Quiz) error {
	if quiz.CreatedAt.IsZero() {
		quiz.CreatedAt = time.Now()
	}
	return s.quizRepo.CreateQuiz(ctx, quiz)
}

// GetQuizByID retrieves a quiz by its ID
func (s *QuizService) GetQuizByID(ctx context.Context, quizID string) (*models.Quiz, error) {
	return s.quizRepo.GetQuizByID(ctx, quizID)
}

// ListAllQuizzes retrieves all quizzes
func (s *QuizService) ListAllQuizzes(ctx context.Context) ([]*models.Quiz, error) {
	return s.quizRepo.ListAllQuizzes(ctx)
}

// InitQuiz transitions quiz from pending→started and initializes Redis namespace
func (s *QuizService) InitQuiz(ctx context.Context, quizID string) (*models.Quiz, error) {
	// Get quiz details to calculate TTL
	quiz, err := s.quizRepo.GetQuizByID(ctx, quizID)
	if err != nil {
		return nil, fmt.Errorf("failed to get quiz: %w", err)
	}

	// Update DB status
	now := time.Now()
	if err := s.quizRepo.UpdateQuizStatus(ctx, quizID, "started", &now); err != nil {
		return nil, fmt.Errorf("failed to update quiz status in DB: %w", err)
	}

	// Calculate TTL: quiz duration + 24 hours for post-quiz viewing
	quizDuration := time.Duration(quiz.DurationMinutes) * time.Minute
	ttl := quizDuration + (24 * time.Hour)

	// Set TTL for all quiz keys (participants, scores, leaderboard, answered)
	if err := s.redisClient.SetQuizTTL(ctx, quizID, ttl); err != nil {
		fmt.Printf("WARNING: failed to set TTL for quiz keys: %v\n", err)
	}

	// Load questions from DB and cache in Redis
	questions, err := s.quizRepo.GetQuestionsByQuizID(ctx, quizID)
	if err != nil {
		return nil, fmt.Errorf("failed to load questions: %w", err)
	}

	// Cache questions in Redis with same TTL
	if len(questions) > 0 {
		if err := s.redisClient.CacheQuestions(ctx, quizID, questions, ttl); err != nil {
			// Log error but don't fail - can fallback to DB
			fmt.Printf("WARNING: failed to cache questions in Redis: %v\n", err)
		}
	}

	// Fetch and return updated quiz
	return s.quizRepo.GetQuizByID(ctx, quizID)
}

// EndQuiz transitions quiz from started→ended and saves final results
func (s *QuizService) EndQuiz(ctx context.Context, quizID string) (*models.Quiz, error) {
	// 1️⃣ Get leaderboard from Redis (cache)
	leaderboard, err := s.redisClient.GetLeaderboard(ctx, quizID, -1)
	if err != nil {
		return nil, fmt.Errorf("failed to get leaderboard from Redis: %w", err)
	}

	// 2️⃣ Save final results to DB FIRST (source of truth) - SYNCHRONOUS
	now := time.Now()
	for rank, entry := range leaderboard {
		result := &models.QuizResult{
			// ID auto-generated by SERIAL
			QuizID:        quizID,
			ParticipantID: entry.ParticipantID,
			FinalScore:    entry.Score,
			Rank:          rank + 1,
			CompletedAt:   now,
		}
		if err := s.resultRepo.SaveResult(ctx, result); err != nil {
			// Log error but continue with other results
			fmt.Printf("WARNING: failed to save result for participant %s: %v\n", entry.ParticipantID, err)
		}
	}

	// 3️⃣ Update quiz status to ended in DB
	if err := s.quizRepo.UpdateQuizStatus(ctx, quizID, "ended", &now); err != nil {
		return nil, fmt.Errorf("failed to update quiz status to ended: %w", err)
	}

	// Note: Redis TTL and event publishing handled elsewhere

	// Fetch and return updated quiz
	return s.quizRepo.GetQuizByID(ctx, quizID)
}

// GetAllStartedQuizzes retrieves all running quizzes
func (s *QuizService) GetAllStartedQuizzes(ctx context.Context) ([]*models.Quiz, error) {
	return s.quizRepo.GetAllStartedQuizzes(ctx)
}

// AddQuestion adds a question to a quiz
func (s *QuizService) AddQuestion(ctx context.Context, q *models.QuizQuestion) error {
	return s.quizRepo.AddQuestion(ctx, q)
}

// DeleteQuestion removes a question from a quiz
func (s *QuizService) DeleteQuestion(ctx context.Context, quizID, questionID string) error {
	return s.quizRepo.DeleteQuestion(ctx, quizID, questionID)
}

// GetQuestion retrieves a specific question
func (s *QuizService) GetQuestion(ctx context.Context, quizID, questionID string) (*models.QuizQuestion, error) {
	return s.quizRepo.GetQuestion(ctx, quizID, questionID)
}

// GetQuestions retrieves all questions for a quiz
func (s *QuizService) GetQuestions(ctx context.Context, quizID string) ([]*models.QuizQuestion, error) {
	return s.quizRepo.GetQuestionsByQuizID(ctx, quizID)
}

// CountQuestions returns the number of questions in a quiz
func (s *QuizService) CountQuestions(ctx context.Context, quizID string) (int, error) {
	return s.quizRepo.CountQuestionsByQuizID(ctx, quizID)
}
